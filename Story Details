STRY1014430 - Remove duplicate ITAM servers by name

Note: Scripted updates for reference (step 3) and attributes (step 4) should skip workflow 
and skip setting system fields by including these 2 functions on the GlideRecord
gr.setWorkflow(false);
gr.autoSysFields(false);

Acceptance criteria:
I know this is complete when scripts are built that will automate:

1. Identification

- Table: cmdb_ci_server & all children
- Discovery Source = ITAM
- Class is Server but NOT IBM Mainframe, IBM Mainframe LPAR, IBM Mainframe Linux, Server Chassis
    (OR Class Is: AIX Server, ESX Server, HPUX Server, Linux Server, Server, Solaris Server, Windows Server)
- More than 1 record by Name

For each set by Name:

2. Primary Record
- Identify primary record as last touched [most recent Updated time stamp]

3. Reference to Task
- All other records, identify if referenced on key table TASK_CI or TASK
- IF reference exists, need to update to sys_id of primary record

4. Mark for deletion
- Mark duplicate record by setting attribute column to: DELETE
- Existing Table Cleaner job will remove duplicate record

Requirement: 

1. Find the duplicate record in the cmdb_ci_server table group by name field and recently updated record using Updated field and
discovery_source as ITAM, sys_class_name is one of AIX Server, ESX Server, HPUX Server, Linux Server, Server, Solaris Server, Windows Server
so here first record is primary record and rest of the records if found then it is duplicate for those records set 'attributes' column as DELETE


2. With the duplicate records found in step 1 get the sys_id of those records and do a query in task_ci table in the ci_item field, 
if the sys_id matches then remove the value from the ci_item field in that record in task_ci table aand set the primary record sys_id of those duplicate 
records which found in step 1.

3. Add these below 2 lines to override for updating the ci_item field in the task_ci table and while setting the attribbutes in the cmds_ci_server table for the duplicate records 
gr.setWorkflow(false);
gr.autoSysFields(false);

4. Since there is a lot of duplicate rcords in the cmdb_ci_server table instead of fix script we have to go for an approach like an schedule job
to delete and update the primary record value in the task_ci table batch wise, schedule job needs to be run every hour

Answer:

executeRule();


function executeRule() {

    var nameToPrimary = {};
    var batchSize = 100;
    var count = 0;
    var duplicateProcessed = 0;

    gs.log('ARK:::[CMDB Cleanup] Deduplicate Servers & Update Task References::: Starting duplicate cleanup job...');

    try {
        //Get the all relevant server records
        var query = 'name=10-34-122-224^discovery_source=ITAM^sys_class_nameINcmdb_ci_aix_server,cmdb_ci_esx_server,cmdb_ci_hpux_server,cmdb_ci_linux_server,cmdb_ci_server,cmdb_ci_solaris_server,cmdb_ci_win_server';
        var serverGr = new GlideRecord('cmdb_ci_server');
        serverGr.addEncodedQuery(query);
        serverGr.orderBy('name');
        serverGr.orderByDesc('sys_updated_on');
        serverGr.query();

        while (serverGr.next() && count < batchSize) {

            var name = serverGr.name.toString();
            if (!name) {
                gs.info('[CMDB Cleanup] Deduplicate Servers & Update Task Reference - Skipping record with missing name = ' + serverGr.sys_id);
                continue;
            }
            if (!nameToPrimary[name]) {
                nameToPrimary[name] = serverGr.sys_id.toString();
                gs.info('ARK:::[CMDB Cleanup Job] Primary record for "' + name + '": ' + serverGR.sys_id);
                continue;
            }

            var duplicateSysId = serverGr.sys_id.toString();
            var primarySysId = nameToPrimary[name];
            gs.info('ARK:::[CMDB Cleanup Job] Found duplicate for "' + name + '" — Duplicate: ' + duplicateSysId + ' | Primary: ' + primarySysId);

            // update task_ci references by finding the duplicates CI's and updating with primmary CI server
            var taskCiGr = new GlideRecord('task_ci');
            taskCiGr.addQuery('ci_item', duplicateSysId);
            taskCiGr.query();
            while (taskCiGr.next()) {
                var taskSysId = taskCiGr.sys_id.toString();
                taskCiGr.setWorkflow(false);
                taskCiGr.autoSysFields(false);
                taskCiGr.ci_item = primarySysId;
                taskCiGr.update();
                gs.info('ARK:::[CMDB Cleanup Job] task_ci record updated: ' + taskSysId + ' | Old CI: ' + duplicateSysId + ' => New CI: ' + primarySysId);
            }

            //Mark the duplicate for the deletion in the attributes column
            serverGr.setWorkflow(false);
            serverGr.autoSysFields(false);
            serverGr.attributes = 'DELETE';
            serverGr.update();
            gs.info('ARK:::[CMDB Cleanup Job] Marked cmdb_ci_server ' + duplicateSysId + ' with attributes = DELETE');
        }

        gs.info('ARK:::[CMDB Cleanup Job] Cleanup complete. Duplicates processed: ' + duplicatesProcessed);

    } catch (globalErr) {
        gs.error('[CMDB Cleanup] Deduplicate Servers & Update Task References. Fatal error: ' + globalErr.message);

    }
}

errors:

[CMDB Cleanup] Deduplicate Servers & Update Task References. Fatal error: "serverGR" is not defined.: no thrown error





-----------------------------------------------------------------------

https://www.servicenow.com/community/developer-forum/createorupdateci-failed-import-set-error/m-p/2798210#M1074596

--------------------------------------------------------


executeRule();


function executeRule() {

    var nameToPrimary = {};
    var batchSize = 100;
    var count = 0;
    var duplicateProcessed = 0;

    //gs.info('[CMDB Cleanup Job] Deduplicate Servers & Update Task References::: Starting duplicate cleanup job...');

    try {
        //Get the all relevant server records
        var query = 'discovery_source=ITAM^sys_class_nameINcmdb_ci_aix_server,cmdb_ci_esx_server,cmdb_ci_hpux_server,cmdb_ci_linux_server,cmdb_ci_server,cmdb_ci_solaris_server,cmdb_ci_win_server^attributes!=DELETE^ORattributesISEMPTY';
        var serverGr = new GlideRecord('cmdb_ci_server');
        serverGr.addEncodedQuery(query);
        serverGr.orderBy('name');
        serverGr.orderByDesc('sys_updated_on');
        //serverGr.setLimit(batchSize);
        serverGr.query();

        while (serverGr.next() && count < batchSize) {

            var name = serverGr.name.toString();

            //Go to the next iteration if the name is empty
            if (!name) {
                continue;
            }

            //Go to the next iterations if the primary server ia found and appened in the object
            if (!nameToPrimary[name]) {
                nameToPrimary[name] = serverGr.sys_id.toString();
                //gs.info('ARK:::[CMDB Cleanup Job] Primary record for "' + name + '": ' + serverGr.sys_id);
                continue;
            }

            var duplicateSysId = serverGr.sys_id.toString();
            var primarySysId = nameToPrimary[name];

            // update task_ci references by finding the duplicates CI's and updating with primmary CI server
            var taskCiGr = new GlideRecord('task_ci');
            taskCiGr.addQuery('ci_item', duplicateSysId);
            taskCiGr.query();
            while (taskCiGr.next()) {
                var taskSysId = taskCiGr.sys_id.toString();
                taskCiGr.setWorkflow(false);
                taskCiGr.autoSysFields(false);
                taskCiGr.ci_item = primarySysId;
                taskCiGr.update();
            }

            //Mark the duplicate for the deletion in the attributes column
            serverGr.setWorkflow(false);
            serverGr.autoSysFields(false);
            serverGr.attributes = 'DELETE';
            serverGr.update();

            //Increase the count value to update the record in batch wise
            count++;
            duplicateProcessed++;
        }
        gs.info('ARK:::[CMDB Cleanup Job] Cleanup complete. Duplicates processed: ' + duplicateProcessed);


    } catch (globalErr) {
        gs.error('[CMDB Cleanup] Deduplicate Servers & Update Task References.Fatal error: ' + globalErr.message);

    }
}
--------------------------------------------------------------------------
STRY1018363 : 

Create a new data source for Casino load balance services and transform map to load the data in to the target table cmdb_ci_endpoint_http.
Give me the perfect name for the data source and transform map, and a new import set table and how it will get created from the data source.

Requirement for creating the transform map
CSV file has 4 columns:

entrypoint_fqdn
load_balancer_hostname
vastid
last_refreshed_dt

Mapping to use for HTTP(S) Endpoint [cmdb_ci_endpoint_http].  Coalesce on URL.

Install Status - default '1' (Installed)
URL - entrypoint_fqdn
Most Recent Discovery [last_discovered] - pull Date value from 'last_refreshed_dt' - incoming format example is: 2025-04-30T14:00:06.885000+00:00


Answer:

if (source.last_refreshed_dt) {
  // Get the raw string from the CSV (example: 2025-04-30T14:00:06.885000+00:00)
  var raw = source.last_refreshed_dt.toString();

  // Step 1: Remove the microseconds (.885000) using a regular expression
  var noMicroseconds = raw.replace(/\.\d+/, '');  
  // Result: "2025-04-30T14:00:06+00:00"

  // Step 2: Remove the timezone offset (+00:00) using another regex
  var cleaned = noMicroseconds.replace(/(\+|\-)\d{2}:\d{2}$/, '');  
  // Result: "2025-04-30T14:00:06"

  // Step 3: Create a GlideDateTime object from the cleaned string
  var gdt = new GlideDateTime(cleaned);  

  // Step 4: Assign it to the target field
  target.last_discovered = gdt;
}

---------------------------------------------

How to test the database indexes in the cmdb_rel_ci table

Here’s a GlideRecord test script to evaluate all three indexes on the cmdb_rel_ci table: parent, type, child, type, and child, parent, type, port.

You can run this in Scripts - Background:

// Test Index 1: parent, type
gs.info('--- Testing index: parent, type ---');
var gr1 = new GlideRecord('cmdb_rel_ci');
gr1.addQuery('parent', 'PUT_PARENT_SYS_ID_HERE');  // replace with actual sys_id
gr1.addQuery('type', 'PUT_TYPE_SYS_ID_HERE');      // replace with actual sys_id
gr1.query();
while (gr1.next()) {
    gs.info('Match (parent, type): ' + gr1.sys_id);
}

// Test Index 2: child, type
gs.info('--- Testing index: child, type ---');
var gr2 = new GlideRecord('cmdb_rel_ci');
gr2.addQuery('child', 'PUT_CHILD_SYS_ID_HERE');    // replace with actual sys_id
gr2.addQuery('type', 'PUT_TYPE_SYS_ID_HERE');      // same type or different
gr2.query();
while (gr2.next()) {
    gs.info('Match (child, type): ' + gr2.sys_id);
}

// Test Index 3: child, parent, type, port
gs.info('--- Testing index: child, parent, type, port ---');
var gr3 = new GlideRecord('cmdb_rel_ci');
gr3.addQuery('child', 'PUT_CHILD_SYS_ID_HERE');    // replace with actual sys_id
gr3.addQuery('parent', 'PUT_PARENT_SYS_ID_HERE');  // replace with actual sys_id
gr3.addQuery('type', 'PUT_TYPE_SYS_ID_HERE');      // replace with actual sys_id
gr3.addQuery('port', 'PUT_PORT_VALUE_HERE');       // replace with actual port value
gr3.query();
while (gr3.next()) {
    gs.info('Match (child, parent, type, port): ' + gr3.sys_id);
}


✅ Optional Debugging:

Before running the script, enable Debug SQL:
	1.	Navigate to System Diagnostics > Session Debug.
	2.	Click Debug SQL ON.
	3.	Then run the script and view logs under System Logs > SQL Logs to confirm which index was used.

--------------------------------------------------------------------------------------------------

Spike story: STRY1018309

Use case:
Import Set "STRY1018309_LoadBalancer_IH-ETL" has the creation of an IntegrationHub ETL job that reads the format of data from Casino to ingest Load Balancer CIs across multiple CI Classes.

This story is to automate the Load Balancer by changing the Scheduled Import 'Casino Load Balancer' from a One-Time load of an attached CSV file, to process daily (10am) by connecting to the Casino API to retrieve the payload as a CSV formatted file.

Technical design element:

Information for Casino API - The Casino API has to be authenticated (Service Account PW can be sent via secure email by Marshall) to use a token to retrieve data. Attached is a how-to guide from Eric Gu on the Casino team.

API URL:  https://network-api.casino-services.verizon.com/
UAT:          https://network-api.casino-services-uat.ebiz.verizon.com/
DEV:         https://network-api.casino-services-dev.ebiz.verizon.com/
SERVICE ACCOUNT:  svc-snow-cmdb-casino
DOMAIN:                     us-win 

Request:
This story is to automate the Load Balancer by changing the Scheduled Import 'Casino Load Balancer' from a One-Time load of an attached CSV file, to process daily (10am) by connecting to the Casino API to retrieve the payload as a CSV formatted file.

Analysis:
The documentation received on how to access network api references curl or python call.  Majority of the time spent in this sprint was done to turn it into a REST call, check to establish the connection and pull the data.  No major blockers were encountered with any firewall or connection issues.   A REST message and a REST flow action are created to test the connection.  The REST action is able to pull back a .csv file and attach it to the data source.
More research is needed to work the REST API connection into integration hub, explore the rest integration type on data source, the use of robust transform maps, error handling and use of data stream to determine the best approach.

Go Forward Plan:
Another 8 point story is needed to research more on this spike.

-----------------------------------------------------------------------------------------------------------------------------

STRY1007797 - Populate WS1 Application Bundle Id in AYS

Analysis:
Scripted REST service:
Software_WS!_Integrations

resources:
update_ws1_softwareApps - HTTP method is POST

resource path URL: /api/verw2/software_ws1_integration/update_ws1_softwareApps

script operations:

(function process(/*RESTAPIRequest*/ request, /*RESTAPIResponse*/ response) {

    var responseObj = {};
	var messageCode = "";
	var messageText = "";
	var hasException = false;
	var exceptionIs = "";
	var status = 500;

	try{
		var mandFields = [];
		var missingFields = [];
		var missing = false;

		var requestBody = request.body;
		var requestString = requestBody.dataString;
		var parsed = JSON.parse(requestString);
		
		var name = parsed.name; 
		if(name==undefined)
		{
			missing=true; 
			missingFields.push("name");
		} 
		mandFields.push("name", name);
		
		var version = parsed.version; 
		if(version==undefined)
		{
			missing=true; 
			missingFields.push("version");
		} 
		mandFields.push("version", version);
		
		var developer = parsed.developer; 
		if(developer==undefined)
		{
			missing=true; 
			missingFields.push("developer");
		} 
		mandFields.push("developer", developer);
		
		var devicetypeID = parsed.devicetypeID;
		if(devicetypeID==undefined)
		{
			missing=true; 
			missingFields.push("devicetypeID");
		} 
		mandFields.push("devicetypeID", devicetypeID);
		
		var applicationID = parsed.applicationID;
		if(applicationID ==undefined)
		{
			missing=true; 
			missingFields.push("applicationID");
		} 
		mandFields.push("applicationID", applicationID);
		
		if(this._checkMandatoryFields(mandFields, missingFields) && missing==false )
		{
			var rec = new GlideRecord("u_ws1_apps");
			rec.addQuery('u_app_id',applicationID);
			rec.query();
			if(rec.next())
				{
					status = 400;
					messageCode = "Operation Failure";
					messageText = "WorkspaceOne application already exists.";
				}
			else
				{
					rec.initialize();
					rec.u_name= name;
					rec.u_version = version;
					rec.u_manufacturer = developer;
					rec.u_platform = devicetypeID;
					rec.u_app_id = applicationID;
					if(rec.insert())
					{
						status = 200;
						messageCode = "Operation Success";
						messageText = "Successful creation of WorkspaceOne application.";
					}
					else
					{
						status = 401;
						messageCode = "Operation Failure";
						messageText = "Unable to create WorkspaceOne application.";
					}
				}
		}
		else
			{
				status = 401;
				messageCode = "Operation Failed";
				messageText = "Missing Mandatory Fields";
			}
	}

	catch(err)
	{
		messageCode = "Operation Failed";
		messageText = "Unable to create WorkspaceOne application.";
		hasException = true;
		exceptionIs = err.toString();
	}

	response.setStatus(status);
	responseObj = {
		"MessageCode": messageCode,
		"MessageText": messageText,
		"HasException": hasException,
		"Exception": exceptionIs
	};
	response.setBody(responseObj);
})(request, response);

function _checkMandatoryFields(mandFields, missingFields){
	var isAllClear = true;
	for(var i = 1; i < mandFields.length; i++){
		if(mandFields[i] == ""){
			isAllClear = false;
			missingFields.push(mandFields[i-1]);
		}i++;
	}
	return isAllClear;
}


Request body example:
{
"name":".NET Core  Runtime & Hosting Bundle",
"version":"2.2.4",
"devicetypeID":"Windows",
"developer":"Microsoft",
"applicationID":"1"
}


table is u-ws1_apps and the field needs to be added is u_bundle_id to be added in the above script

-----------------------------------------------------------------------------------------
STRY1010254 - Widget update 
Widget Name: Cancel Request
HTML Template:
<div ng-if="data.table == 'sc_request'" class="panel panel-default">
   
    <div ng-if="data.allowReqCancel">
      <div class="panel-body">
    <h3 class="panel-title">
      Don't need to do this anymore? Feel free to cancel your request.
    </h3>
      
    <br>
    <label>Cancellation comments:</label>
    <br>
    <textarea ng-model="data.comments" ng-Keydown="keyDown(data.sys_id);" ng-click="keyDown(data.sys_id);" placeholder="*Required to Cancel{{data.methodName}}" class="form-control txt-cancel" rows="3" id="{{data.sys_id}}"></textarea>
  <br/>
    <button type="button" class="btn btn-default" ng-click="c.uiAction('cancel')">Cancel this Request</button>     
    </div>
  </div>
  </div>

Server Script:
(function() {

	// Get table & sys_id
	data.table = input.table || $sp.getParameter("table");
	data.sys_id = input.sys_id || $sp.getParameter("sys_id");

	//To display the widget.
	data.allowReqCancel = false;
	if (data.table == 'sc_request') {
		var req = new GlideRecord("sc_request");
		req.addQuery("sys_id", data.sys_id);
		req.query();
		
		var ritmGr1 = new GlideRecord('sc_req_item');
		ritmGr1.addQuery('request', data.sys_id);
		ritmGr1.addQuery('cat_item', '!=', '7646fef2dbc92c5085e74cd23996191b'); // Dont allow user to cancel request for Computer Refresh form
		ritmGr1.addQuery('cat_item', '!=', 'b047048f132ad200727db9785144b024'); // Don't allow users to cancel request for Desktop, Laptop, Mac Requests form
		ritmGr1.query();
		ritmGr1.getRowCount();

		if (ritmGr1.next()) {
			if(req.next() && req.getDisplayValue('active') == 'true'){
				//STRY0998494 - Allowing cancellation for the Order guide requests
				if (ritmGr1.getRowCount() >= 1 && ritmGr1.getDisplayValue('active') == 'true' && (gs.getUserID() == ritmGr1.getValue('opened_by') || gs.getUserID() == ritmGr1.getValue('u_requested_for'))) { 
					data.allowReqCancel = true;
				}
				if (ritmGr1.getRowCount() > 1 && gs.getUserID() == ritmGr1.getValue('opened_by')) {
					data.allowReqCancel = true;
				}
			}
		}
	}

	// Valid GlideRecord
	var gr = new GlideRecord(data.table);
	if (!gr.isValid())
		return;

	// Valid sys_id
	if (!gr.get(data.sys_id))
		return;

	if (input && input.action) {
		var action = input.action;

		// If SC Request table
		if (data.table == 'sc_request') {
			if (action == 'cancel') {
				/*if (gr.active == true){
                	gr.request_state = 'closed_cancelled';
                	gr.update();
                	new UIActionUtils().approvalsNoLongerRequired(data.sys_id);
                }*/

				var ritmGr = new GlideRecord('sc_req_item');
				ritmGr.addQuery('request', data.sys_id);
				ritmGr.query();
				//var ritmCount = ritmGr.getRowCount();

				while (ritmGr.next()) {
					var stageVal = ritmGr.getValue('stage').toUpperCase();


					if (ritmGr.getDisplayValue('active') == 'true' && (gs.getUserID() == ritmGr.getValue('opened_by') || gs.getUserID() == ritmGr.getValue('u_requested_for'))) {
						gr.request_state = 'closed_cancelled';
						ritmGr.comments = "Cancel Request : " + input.comments;
						ritmGr.update();
						new UIActionUtils().approvalsNoLongerRequired(data.sys_id);
					}
				}
				gs.addInfoMessage('Request has been cancelled.');
				gr.update();
			}
		}
	}
})();

CLient Contorller:
api.controller = function(spUtil, $window, $scope) {
    /* widget controller */
    var c = this;
    $scope.data.loadUpdate = false;
	c.uiAction = function(action) {
	
		var comments = $scope.data.comments;
        if (null == comments || comments === "" || (comments === "*Required to " + action)) {
					if($scope.data.table == 'sc_request')
            spUtil.addErrorMessage("Comment is required to " + action + " Request.");
            return;
        }
		var x = {};
		var sys_id = $scope.data.sys_id;
		x.sys_id = sys_id;
		x.table = $scope.data.table; 
		
		

		if($scope.data.table == 'sc_request'){
			x.method = 'closed_cancelled';
			x.comments = comments.trim();
		}
			else {
			return;
		}
		$scope.data.sys_id = x.sys_id;
        c.data.action = action;
        c.server.update().then(function() {
        c.data.action = undefined;
			  $window.location.reload();
        });
    };
};

if cat_item is Computer Accessories and u_requested_for or logged in user is a member of this
NIT_SHI_PROCUREMENT assignment group and a variable in the requested item
called is pr_number should be generated then we can allow the logged in user to
cancel this requested item from the portal, they can click the button called ‘Cancel
this Requested’ if the condition fails this widget should not get visible in the
portal and it should not impact on any existing code with this above logic.

How to achieve this scenario in the above code?
..................................................................................................

UI Action: RITM
Action name: Button

condition: 
new VZ_SC_CancelRequestOrRITM().fnCheckCancelRITM(current)

Script:
var cancelRITM = new VZ_SC_CancelRequestOrRITM().fnCancelRITM(current.sys_id, current.comments);
if(!cancelRITM){
	current.setAbortAction(true);
}

Script include functions:

    fnCheckCancelRITM: function(current) {
        //var stageVal = current.stage.toUpperCase();	
        var allowCancel = false;

        /*if (('REQUEST CANCELLED' != stageVal && 'COMPLETE' != stageVal && 'COMPLETED' != stageVal && 'VERIFICATION' != stageVal && 'DELIVERY' != stageVal)
        	&& current.active == true 
        	&& (gs.hasRole('catalog_admin') || gs.getUserID() == current.request.requested_for || gs.getUserID() == current.request.u_contact || gs.getUserID() == current.opened_by)
        	)
        {
        	
        	allowCancel = true;	
        	
        	var tskGr = new GlideRecord('sc_task');
        		tskGr.addQuery('request_item',current.sys_id);
        		tskGr.addQuery('u_integration_task', 'true');
        		tskGr.query();
        		
        		if(tskGr.getRowCount() > 0){
        			allowCancel = false;				
        		} 
        }*/
        if (current.active == true &&
            (gs.getUserID() == current.u_requested_for || gs.getUserID() == current.request.u_contact || gs.getUserID() == current.opened_by) &&
            (current.state != 3 || current.state != 4 || current.state != 8) &&
            (current.cat_item != '7646fef2dbc92c5085e74cd23996191b') && (current.cat_item != 'b047048f132ad200727db9785144b024')) {         
                allowCancel = true;
            }
        return allowCancel;
    },

if cat_item is Computer Accessories and u_requested_for or logged in user is a member of this
NIT_SHI_PROCUREMENT assignment group and a variable in the requested item
called is pr_number should be generated then we can allow the logged in user to
cancel this requested item in the Native(platform) UI in the UI action, the above code is existing 
code it should not impact the existing code and create this logic as a separate function so that it can be
reused

How to implement this scenario without affecting the existing code?

answer:

fnCheckComputerAccessoriesRITM: function(current) {
    var ritmGr;

    // Handle if current is sc_req_item
    if (current.getTableName() == 'sc_req_item') {
        ritmGr = current;
    }

    // Handle if current is sc_request
    else if (current.getTableName() == 'sc_request') {
        var temp = new GlideRecord('sc_req_item');
        temp.addQuery('request', current.sys_id);
        temp.addQuery('cat_item.name', 'Computer Accessories'); // Optimize early
        temp.query();
        if (!temp.next()) return false;
        ritmGr = temp;
    } else {
        return false; // Unsupported table
    }

    // Validate catalog item
    var catItem = ritmGr.cat_item.name + "";
    if (catItem != 'Computer Accessories') return false;

    // Validate group membership (either user or requested_for)
    var loggedInUser = gs.getUserID();
    var requestedFor = ritmGr.getValue('u_requested_for');

    var groupCheck = new GlideRecord('sys_user_grmember');
    groupCheck.addQuery('group.name', 'NIT_SHI_PROCUREMENT');
    groupCheck.addQuery('user', 'IN', [loggedInUser, requestedFor].join(','));
    groupCheck.query();

    if (!groupCheck.hasNext()) return false;

    // Check if pr_number exists and has value
    var prNumber = "";
    var mtom = new GlideRecord('sc_item_option_mtom');
    mtom.addQuery('request_item', ritmGr.getUniqueValue());
    mtom.query();

    while (mtom.next()) {
        var optionGR = new GlideRecord('sc_item_option');
        if (!optionGR.get(mtom.getValue('sc_item_option'))) continue;

        var defGR = new GlideRecord('item_option_new');
        if (!defGR.get(optionGR.getValue('item_option_new'))) continue;

        if (defGR.name == 'pr_number') {
            prNumber = optionGR.getValue('value') + "";
            break;
        }
    }

    return prNumber != "";
}
..............................................................
fnCancelRITM: function(sysid, comments) {
        var status = false;
        var scGr = new GlideRecord("sc_req_item");
        if (comments && null == comments || comments == '') {
            gs.addErrorMessage('Please include additional comments indicating reason for cancellation.');
        } else {
            var allowCancel = false;

            if (scGr.get(sysid)) {
                var stageVal = scGr.stage.toUpperCase();

                if (('REQUEST CANCELLED' != stageVal && 'COMPLETE' != stageVal && 'COMPLETED' != stageVal && 'VERIFICATION' != stageVal && 'DELIVERY' != stageVal) &&
                    scGr.active == true &&
                    (gs.getUserID() == scGr.u_requested_for || gs.getUserID() == scGr.request.u_contact || gs.getUserID() == scGr.opened_by)
                ) {

                    allowCancel = true;

                    var tskGr = new GlideRecord('sc_task');
                    tskGr.addQuery('request_item', scGr.sys_id);
                    tskGr.addQuery('u_integration_task', 'true');
                    tskGr.query();

                    if (tskGr.getRowCount() > 0) {
                        allowCancel = false;
                    }
                }

                if (allowCancel) {
                    scGr.stage = 'Request Cancelled';
                    scGr.comments = 'Cancel RITM: ' + comments;
                    scGr.state = '8';
                    scGr.active = false;
                    scGr.update();
                    status = true;
                } else {
                    gs.addErrorMessage('Unable to cancel your request because the automated delivery process has already started.');
                }

            }

        }

        return status;
    },
...............................................................

UI Action: REQUEST
Action name: Cancel Request

Condition: 
 (new VZ_SC_CancelRequestOrRITM().fnCheckCancelRequest(current))

script:
var cancelRequest = new VZ_SC_CancelRequestOrRITM().fnCancelRequest(current.sys_id, current.comments);
if(!cancelRequest){
	current.setAbortAction(true);
}


script include:
  fnCheckCancelRequest: function(current) {
        var allowCancel = false;
        var stateVal = current.state;
        var req = new GlideRecord('sc_req_item');
        req.addQuery('request', current.sys_id);
        req.addQuery('cat_item', '!=', '7646fef2dbc92c5085e74cd23996191b');
		req.addQuery('cat_item', '!=', 'b047048f132ad200727db9785144b024');//to hide cancel button for stry STRY0883145
        req.addActiveQuery();
        req.query();
        if (req.next()) {
            if ((gs.getUserID() == current.u_contact || gs.getUserID() == current.opened_by) &&
                ('7' != stateVal && '4' != stateVal && '3' != stateVal)) {
                allowCancel = true;
                
            }
            if (!allowCancel && ('7' != stateVal && '4' != stateVal && '3' != stateVal)) {
                var ri = new GlideAggregate('sc_req_item');
                ri.addQuery('request', current.sys_id);
                ri.addAggregate('COUNT', 'u_requested_for');
                ri.query();
                if (ri.getRowCount() == 1) {
                    ri.next();
                    if (gs.getUserID() == ri.getValue('u_requested_for')) {
                        allowCancel = true;
                    }
                }
            }
        }

        return allowCancel;
    },
..........................................

fnCancelRequest: function(sysid, comments) {
        var app = new GlideRecord('sc_request');
        var status = false;
        if (comments && null == comments || comments == '') {
            gs.addErrorMessage('Please include additional comments indicating reason for cancellation.');
            return status;
        }

        if (app.get(sysid)) {

            var cancelRITM = [];

            var ritmGr = new GlideRecord('sc_req_item');
            ritmGr.addQuery('request', sysid);
            ritmGr.query();

            var ritmCount = ritmGr.getRowCount();

            while (ritmGr.next()) {
                var stageVal = ritmGr.getValue('stage').toUpperCase();

                if (('REQUEST CANCELLED' != stageVal && 'COMPLETE' != stageVal &&
                        'COMPLETED' != stageVal && 'VERIFICATION' != stageVal && 'DELIVERY' != stageVal) && ritmGr.getValue('active') == true &&
                    (gs.getUserID() == ritmGr.u_requested_for || gs.getUserID() == app.u_contact || gs.getUserID() == app.opened_by)) {

                    var allowCancel = true;
                    var tskGr = new GlideRecord('sc_task');
                    tskGr.addQuery('request_item', ritmGr.getValue('sys_id'));
                    tskGr.addQuery('u_integration_task', 'true');
                    tskGr.query();

                    if (tskGr.getRowCount() > 0) {
                        allowCancel = false;
                    }

                    if (allowCancel) {
                        cancelRITM.push(ritmGr.getValue('sys_id').toString());
                    }
                }
            }

            if (cancelRITM && cancelRITM.length > 0) {
                for (var i = 0; i < cancelRITM.length; i++) {
                    var ritmApp = new GlideRecord('sc_req_item');
                    ritmApp.get(cancelRITM[i]);
                    if (ritmApp) {
                        ritmApp.comments = 'Cancel Request: ' + comments;
                        ritmApp.stage = 'Request Cancelled';
                        ritmApp.state = '8';
                        ritmApp.active = false;
                        ritmApp.update();
                    }
                }

                app.comments = 'Cancel Request: ' + comments;
                app.update();
                status = true;

            } else {

                if (ritmCount == 0) {
                    app.request_state = 'closed_cancelled';
                    app.stage = 'closed_complete';
                    app.comments = 'Cancel Request: ' + comments;
                    app.update();
                    status = true;
                } else {
                    //app.comments = 'Dependencies detected. Unable to Cancel Request. User comments: ' + comments;
                    //app.update();
                    gs.addErrorMessage('Unable to cancel your request because the automated delivery process has already started.');
                }

            }
        }
        return status;
    },

---------------------------------------------------------------------------------------------------------------------







